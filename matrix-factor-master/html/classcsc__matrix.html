<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>matrix-factor: csc_matrix&lt; idx_type, el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">matrix-factor&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Incomplete LDL' factorizations of symmetric matrices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">csc_matrix&lt; idx_type, el_type &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="csc_matrix" --><!-- doxytag: inherits="abstract_sparse_matrix" -->
<p>A matrix using the compressed sparse column format.  
 <a href="classcsc__matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="csc__matrix__declarations_8h_source.html">csc_matrix_declarations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for csc_matrix&lt; idx_type, el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix__inherit__graph.png" border="0" usemap="#csc__matrix_3_01idx__type_00_01el__type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="csc__matrix_3_01idx__type_00_01el__type_01_4_inherit__map" id="csc__matrix_3_01idx__type_00_01el__type_01_4_inherit__map">
<area shape="rect" id="node2" href="classabstract__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="4,5,301,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for csc_matrix&lt; idx_type, el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix__coll__graph.png" border="0" usemap="#csc__matrix_3_01idx__type_00_01el__type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="csc__matrix_3_01idx__type_00_01el__type_01_4_coll__map" id="csc__matrix_3_01idx__type_00_01el__type_01_4_coll__map">
<area shape="rect" id="node2" href="classabstract__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="25,109,323,136"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classcsc__matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, <br class="typebreak"/>
el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a1c762ce19c1b0a677a81ad1935bff09f">csc_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classabstract__sparse__matrix.html">abstract_sparse_matrix</a><br class="typebreak"/>
&lt; idx_type, el_type &gt;<br class="typebreak"/>
::<a class="el" href="classabstract__sparse__matrix.html#a1d8119750a2ce4eadbc06e93d68900ab">idx_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a9092a1116421a0594f3af2c1aac75489">idx_vector_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classabstract__sparse__matrix.html">abstract_sparse_matrix</a><br class="typebreak"/>
&lt; idx_type, el_type &gt;<br class="typebreak"/>
::<a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">elt_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a9494158d2865a2191a184dd0330ed298">elt_vector_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#af7c76a131321aa29ff3c31b1a052dd76">csc_matrix</a> (idx_type n_rows=0, idx_type n_cols=0, idx_type nz_max=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual idx_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a6a956b3480b07fe4abba088ed3c74de9">nnz</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a48a009bcb2deb370af01f313ea6ae8bf">coeff</a> (const idx_type &amp;i, const idx_type &amp;j) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a9cdbdb1db7e864d3626d63f65a820b70">resize</a> (idx_type n_rows, idx_type n_cols, idx_type n_nzs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a310f5db603cf79a961db26d7013bea45">ildl</a> (<a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt; &amp;L, <a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">elt_vector_type</a> &amp;D, int lfil, double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a0f0b70b055118308c9ffd7acf596b17c">to_string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a4614f32a3d6cf63e0d006f475e2d44c7">load</a> (std::string filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsc__matrix.html#a8eabd2e218a42e3a38d0b50493a669f3">save</a> (std::string filename)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class idx_type, class el_type&gt;<br/>
class csc_matrix&lt; idx_type, el_type &gt;</h3>

<p>A matrix using the compressed sparse column format. </p>
<p>In compressed sparse column storage, the col_idx array is of size N + 1. col_idx[j] gives the starting position of the first non-zero element in column j. Hence col_idx[j+1] - col_idx[j] gives the total number of non-zero values in column j and therefore, col_idx[n_cols] gives the total number of non-zero elements in the matrix.</p>
<p>row_idx[j] and m_x[j] are arrays of size n_nzs, so col_idx[n_cols] == row_idx.size() </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a1c762ce19c1b0a677a81ad1935bff09f"></a><!-- doxytag: member="csc_matrix::csc_t" ref="a1c762ce19c1b0a677a81ad1935bff09f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt;idx_type, el_type&gt; <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::<a class="el" href="classcsc__matrix.html">csc_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9494158d2865a2191a184dd0330ed298"></a><!-- doxytag: member="csc_matrix::elt_vector_type" ref="a9494158d2865a2191a184dd0330ed298" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classabstract__sparse__matrix.html">abstract_sparse_matrix</a>&lt;idx_type, el_type&gt;::<a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">elt_vector_type</a> <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::<a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">elt_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">abstract_sparse_matrix&lt; idx_type, el_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9092a1116421a0594f3af2c1aac75489"></a><!-- doxytag: member="csc_matrix::idx_vector_type" ref="a9092a1116421a0594f3af2c1aac75489" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classabstract__sparse__matrix.html">abstract_sparse_matrix</a>&lt;idx_type, el_type&gt;::<a class="el" href="classabstract__sparse__matrix.html#a1d8119750a2ce4eadbc06e93d68900ab">idx_vector_type</a> <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::<a class="el" href="classabstract__sparse__matrix.html#a1d8119750a2ce4eadbc06e93d68900ab">idx_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classabstract__sparse__matrix.html#a1d8119750a2ce4eadbc06e93d68900ab">abstract_sparse_matrix&lt; idx_type, el_type &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7c76a131321aa29ff3c31b1a052dd76"></a><!-- doxytag: member="csc_matrix::csc_matrix" ref="af7c76a131321aa29ff3c31b1a052dd76" args="(idx_type n_rows=0, idx_type n_cols=0, idx_type nz_max=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::<a class="el" href="classcsc__matrix.html">csc_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>nz_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                              : 
        <a class="code" href="classabstract__sparse__matrix.html" title="The abstract parent of all sparse matrices.">abstract_sparse_matrix&lt;idx_type, el_type&gt;</a> (<a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>, <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>, <a class="code" href="classabstract__sparse__matrix.html#a22f002058b8b4266820440a7301a5299">nz_max</a>) 
    {
                <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.reserve(<a class="code" href="classabstract__sparse__matrix.html#a22f002058b8b4266820440a7301a5299">nz_max</a>);
        <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>.resize (n_cols + 1);
    }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix_af7c76a131321aa29ff3c31b1a052dd76_cgraph.png" border="0" usemap="#classcsc__matrix_af7c76a131321aa29ff3c31b1a052dd76_cgraph" alt=""/></div>
<map name="classcsc__matrix_af7c76a131321aa29ff3c31b1a052dd76_cgraph" id="classcsc__matrix_af7c76a131321aa29ff3c31b1a052dd76_cgraph">
<area shape="rect" id="node3" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc" title="abstract_sparse_matrix::n_cols" alt="" coords="220,5,436,32"/><area shape="rect" id="node5" href="classabstract__sparse__matrix.html#a22f002058b8b4266820440a7301a5299" title="abstract_sparse_matrix::nz_max" alt="" coords="216,56,440,83"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a48a009bcb2deb370af01f313ea6ae8bf"></a><!-- doxytag: member="csc_matrix::coeff" ref="a48a009bcb2deb370af01f313ea6ae8bf" args="(const idx_type &amp;i, const idx_type &amp;j) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual el_type <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype">const idx_type &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const idx_type &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the (i,j)th coefficient of the matrix. Uses binary search to find an element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (i,j)th element of the matrix. </dd></dl>

<p>Implements <a class="el" href="classabstract__sparse__matrix.html#a74047578e7a2725d2eb4239d68cc643d">abstract_sparse_matrix&lt; idx_type, el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">                                                                          {
                <span class="keyword">typename</span> idx_vector_type::const_iterator low = lower_bound(<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.begin() + <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[j], <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.begin() + <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[j+1], i);
                <span class="keywordflow">return</span> (*low == i) ? *(<a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>.begin() + std::distance(<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.begin(), low)) : 0;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a310f5db603cf79a961db26d7013bea45"></a><!-- doxytag: member="csc_matrix::ildl" ref="a310f5db603cf79a961db26d7013bea45" args="(csc_matrix&lt; idx_type, el_type &gt; &amp;L, elt_vector_type &amp;D, int lfil, double tol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type , class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::ildl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabstract__sparse__matrix.html#a2f9b32d149519131b4c13aa145a9059a">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lfil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs an LDL' factorization of this matrix. The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005). Results are stored in L and D. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>the L factor of this matrix. </td></tr>
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">lfil</td><td>a parameter to control memory usage. Each column is guarannted to have fewer than lfil elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped.</td></tr>
  </table>
  </dd>
</dl>
<p>possible optimizations/to-do's:</p>
<ul>
<li>some easy parallelization of for loops.</li>
</ul>
<ul>
<li>using a vector to accumulate all nonzeros in previous cols during iteration.</li>
</ul>
<ul>
<li>small changes to loops (e.g. assign .begin(), and .end() so that they will not be evaluated each iter. ---&gt; for (auto itr = new_values.begin(), end_itr = new_values.end(); itr != end_itr; ++itr ) )</li>
</ul>
<ul>
<li>make a special diagonal matrix class for storing 1x1 and 2x2 pivots later.</li>
</ul>
<ul>
<li>typedef some of the std::vector&lt;...&gt; into more readable names.</li>
</ul>
<ul>
<li>use epsilon tolerances in comparing doubles later. </li>
</ul>
<div class="fragment"><pre class="fragment">{       
        <span class="comment">//Llist is a deque of linked lists that gives the non-zero elements in each row of L. since at any time we may swap between two rows, we require a linked lists for each row of L. a deque is used as it might be desireable to deallocate all linked lists for rows i &lt; k on step k (this is currently not done, as the memory used in maintaining linked lists for all rows is not much).</span>
        std::vector&lt; std::deque&lt; idx_type &gt; &gt; Llist; 
        
        <span class="comment">//work is a work vector for the current column. Lfirst is a linked list that gives the first nonzero element in column k with row index i &gt; k. (i.e. the first nonzero in L(k+1:n, k).</span>
        std::vector&lt;el_type&gt; work(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(), 0), temp(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(), 0);
        
        std::vector&lt;idx_type&gt; curr_nnzs, temp_nnzs, Lfirst(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(), 0); <span class="comment">//non-zeros on current col.</span>
        
        <span class="keywordtype">int</span> count = 0; <span class="comment">//the current non-zero in L.</span>
        <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = (1+sqrt(17))/8;  <span class="comment">//for use in pivoting.</span>
        idx_type i, j, k, offset, r;
        el_type l_ik, w1, wr;
        
        curr_nnzs.reserve(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>()); <span class="comment">//makes sure that there is enough space if every element in the column is nonzero</span>
        Llist.resize(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>()); <span class="comment">//allocate a vector of size n for Llist.</span>
        
        L.<a class="code" href="classcsc__matrix.html#a9cdbdb1db7e864d3626d63f65a820b70">resize</a>(<a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>(), <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(), (lfil+1)*<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>()); <span class="comment">//(+1 because there are 1s on the diagonal. they wont need to be stored if we want to optimize)</span>
        D.resize(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>()); 
        
        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(); i++) {
                D[i] = <a class="code" href="classcsc__matrix.html#a48a009bcb2deb370af01f313ea6ae8bf">coeff</a>(i,i);
        }
        
        <span class="keywordflow">for</span> (k = 0; k &lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(); k++) {
            <span class="comment">//zero out work vector</span>
            std::fill (work.begin() + k, work.end(), 0);
            
            <span class="comment">//the +1 avoids assigning diagonal element as nonzero since its stored in D. the min is in case m_col_idx[k] == m_col_idx[k+1] (an empty column).</span>
            curr_nnzs.assign (<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.begin() + min(<a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k] + 1, <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k+1]), <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.begin() + <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k+1]);
                
                <span class="comment">//assigns the non zeros in A(k,:) to the work vector. since only the lower diagonal of A is stored, this is essentially A(k,k+1:n).</span>
            <span class="keywordflow">for</span> (j = <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k] + 1; j &lt; <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k+1]; j++) {
                        work[<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[j]] = <a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[j];
                }
                
                <span class="keywordflow">if</span> (k &lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>() - 1) {
                        <span class="comment">//--------------begin pivoting--------------//</span>
                        <span class="comment">//perform delayed updates on the current col (k) of A</span>
                        <a class="code" href="csc__matrix__ildl__helpers_8h.html#a89d88cfc799f1fb717df5f3f08bf7389" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(k, work, curr_nnzs, L, D, Lfirst, Llist);
                        
                        w1 = <a class="code" href="csc__matrix__ildl__helpers_8h.html#aed0918ead8ed4312ff691fda0bee2566" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(work, curr_nnzs, r);
                        <span class="keywordflow">if</span> (w1 == 0) {
                                <span class="comment">//case 0: do nothing. pivot is k.</span>
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(D[k]) &gt;= alpha * w1 ) {
                                <span class="comment">//case 1: do nothing. pivot is k.</span>
                        } <span class="keywordflow">else</span> {
                                <span class="keywordflow">continue</span>; <span class="comment">//have not finished implementing pivoting just yet.</span>
                                
                                <span class="comment">//assign A(k+1:n, r) to temp. also update the diagonal elements. we&#39;ll need a_rr</span>
                                <span class="comment">/* </span>
<span class="comment">                                </span>
<span class="comment">                                        fill in code here </span>
<span class="comment">                                </span>
<span class="comment">                                */</span>
                                
                                <span class="comment">//perform delated updates on col (r) of A.</span>
                                <a class="code" href="csc__matrix__ildl__helpers_8h.html#a89d88cfc799f1fb717df5f3f08bf7389" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(r, temp, temp_nnzs, L, D, Lfirst, Llist);
                                wr = <a class="code" href="csc__matrix__ildl__helpers_8h.html#aed0918ead8ed4312ff691fda0bee2566" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(temp, temp_nnzs, r);
                                <span class="keywordflow">if</span> (std::abs(D[k] * wr)&gt;= alpha*w1*w1) {
                                        <span class="comment">//case 2: do nothing. pivot is k.</span>
                                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(D[r]) &gt;= alpha * wr) {
                                        <span class="comment">//case 3: pivot is k with r. 1x1 pivot.</span>
                                        <span class="comment">/*</span>
<span class="comment">                                        pivot(k,r);</span>
<span class="comment">                                        */</span>
                                        
                                        work.swap(temp);        <span class="comment">//swap work with temp.</span>
                                        curr_nnzs.swap(temp_nnzs);      <span class="comment">//swap curr_nnzs with temp_nnzs</span>
                                } <span class="keywordflow">else</span> {
                                        <span class="comment">//case 4: pivot is k+1 with r: 2x2 pivot case.</span>
                                        <span class="comment">/*</span>
<span class="comment">                                        pivot(k+1,r);</span>
<span class="comment">                                        */</span>
                                }
                        }
                        
                        <span class="comment">//--------------end pivoting--------------//</span>
                        
                        <span class="comment">//performs the dual dropping procedure.</span>
                        <a class="code" href="csc__matrix__ildl__helpers_8h.html#ab97bd15d8d3486326ee4ee72b30b047e" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(work, curr_nnzs, lfil, tol);
                        
                }
                <span class="comment">//get 1s on the diagonal</span>
                L.<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[count] = k;
                L.<a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[count] = 1;
                count++;

                <span class="keywordflow">if</span> (k &lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>() - 1)
                <span class="keywordflow">for</span> (i = 0; i &lt; (idx_type) std::min(lfil, (<span class="keywordtype">int</span>) curr_nnzs.size()); i++) {
                    L.<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[count] = curr_nnzs[i]; <span class="comment">//row_idx of L is updated</span>
                    L.<a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[count] = work[curr_nnzs[i]]/D[k]; <span class="comment">//work vector is scaled by D[k]</span>
                        Llist[curr_nnzs[i]].push_back(k); <span class="comment">//update Llist</span>
                        count++;
                }
                
                L.<a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k+1] = count; <span class="comment">//the end of the current column is assigned to col_idx</span>
                
                <span class="keywordflow">if</span> (k &lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>() - 1) {
                        <span class="comment">//finds out where L(k+1:n, k) starts</span>
                        offset = L.<a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k] + Lfirst[k] + 1;
                        <span class="keywordflow">for</span> (i = offset; i &lt; L.<a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k+1]; i++) {
                                l_ik = L.<a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[i];
                                D[L.<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[i]] -= l_ik * D[k] * l_ik;        <span class="comment">//update diagonal</span>
                        }
                }
        }
        
        <span class="comment">//resize vectors of L down to the right size.</span>
        L.<a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.resize(count); 
        L.<a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>.resize(count);
        
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix_a310f5db603cf79a961db26d7013bea45_cgraph.png" border="0" usemap="#classcsc__matrix_a310f5db603cf79a961db26d7013bea45_cgraph" alt=""/></div>
<map name="classcsc__matrix_a310f5db603cf79a961db26d7013bea45_cgraph" id="classcsc__matrix_a310f5db603cf79a961db26d7013bea45_cgraph">
<area shape="rect" id="node3" href="csc__matrix__ildl__helpers_8h.html#ab97bd15d8d3486326ee4ee72b30b047e" title="Performs the dual&#45;dropping criteria outlined in Li &amp; Saad (2005)." alt="" coords="195,5,269,32"/><area shape="rect" id="node5" href="csc__matrix__ildl__helpers_8h.html#aed0918ead8ed4312ff691fda0bee2566" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index." alt="" coords="208,56,256,83"/><area shape="rect" id="node7" href="classcsc__matrix.html#a9cdbdb1db7e864d3626d63f65a820b70" title="csc_matrix::resize" alt="" coords="165,107,299,133"/><area shape="rect" id="node13" href="csc__matrix__ildl__helpers_8h.html#a89d88cfc799f1fb717df5f3f08bf7389" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs." alt="" coords="199,157,265,184"/><area shape="rect" id="node9" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc" title="abstract_sparse_matrix::n_cols" alt="" coords="349,56,565,83"/><area shape="rect" id="node11" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c" title="abstract_sparse_matrix::n_rows" alt="" coords="347,107,568,133"/><area shape="rect" id="node15" href="csc__matrix__ildl__helpers_8h.html#a0a185c1bdf4296a723845f2ab561778d" title="Performs an inplace union of two sorted lists (a and b), removing duplicates in the final list..." alt="" coords="403,157,512,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4614f32a3d6cf63e0d006f475e2d44c7"></a><!-- doxytag: member="csc_matrix::load" ref="a4614f32a3d6cf63e0d006f475e2d44c7" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type , class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be loaded. Must be in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
  std::ifstream input(filename.c_str(), std::ios::in);

  <span class="keywordflow">if</span>(!input) <span class="keywordflow">return</span> <span class="keyword">false</span>;
  
  <span class="keyword">const</span> <span class="keywordtype">int</span> maxBuffersize = 2048;
  <span class="keywordtype">char</span> buffer[maxBuffersize];
  
  <span class="keywordtype">bool</span> readsizes = <span class="keyword">false</span>;
  
  idx_type <a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>(-1), <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>(-1), n_nzs(-1), prev_j(0), i(-1), j(-1), k;
  <span class="keywordtype">int</span> count = 0, prev_count = 0; 
  <span class="keywordflow">while</span>(input.getline(buffer, maxBuffersize))
  {
    <span class="comment">// skip comments   </span>
    <span class="comment">//NOTE An appropriate test should be done on the header to get the symmetry</span>
    <span class="keywordflow">if</span>(buffer[0]==<span class="charliteral">&#39;%&#39;</span>)
      <span class="keywordflow">continue</span>;
    
    std::stringstream line(buffer);
    
    <span class="keywordflow">if</span>(!readsizes)
    {
      line &gt;&gt; <a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a> &gt;&gt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a> &gt;&gt; n_nzs;
      <span class="keywordflow">if</span>(<a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a> &gt; 0 &amp;&amp; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a> &gt; 0 &amp;&amp; n_nzs &gt; 0) 
      {
        readsizes = <span class="keyword">true</span>;
        <span class="comment">//std::cout &lt;&lt; &quot;Sizes: &quot; &lt;&lt; n_rows &lt;&lt; &quot;, &quot; &lt;&lt; n_cols &lt;&lt; &quot;, &quot; &lt;&lt; n_nzs &lt;&lt; &quot;\n&quot;;</span>
                <a class="code" href="classcsc__matrix.html#a9cdbdb1db7e864d3626d63f65a820b70">resize</a>(<a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>, <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>, n_nzs);
      }
    }
    <span class="keywordflow">else</span>
    { 
      i = -1;
          j = -1;
      el_type value; 
      <span class="keywordflow">if</span>( <a class="code" href="csc__matrix__load_8h.html#a41ea61857cb4937c99d1191af9db075b">readline</a>(line, <a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>, <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>, i, j, value) ) 
      {
                <span class="keywordflow">if</span> (prev_j != j)
                {       
                        <span class="comment">//std::cout &lt;&lt; prev_j &lt;&lt; &quot; transitioning to &quot; &lt;&lt; j &lt;&lt; &quot; on element number: &quot; &lt;&lt; count &lt;&lt; std::endl;</span>
                        <span class="keywordflow">for</span> (k = prev_j; k &lt; j; k++) <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[k] = prev_count;
                        <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[j] = count;
                        prev_count = count;
                        prev_j = j;
                }
                
                <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[count] = i;
        <a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[count] = value;
                ++count;
      }
      <span class="keywordflow">else</span> 
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid read: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;         
    }
        
  }

  <span class="keywordflow">for</span> (i = prev_j+1; i &lt;= <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>; i++) <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[i] = n_nzs;
  
  <span class="keywordflow">if</span>(count!=n_nzs)
    std::cerr &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot; elements read but expected &quot;</span> &lt;&lt; n_nzs &lt;&lt; <span class="stringliteral">&quot;elements. \n&quot;</span>;
  
  std::cout &lt;&lt; <span class="stringliteral">&quot;Load succeeded. &quot;</span> &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; was loaded.&quot;</span> &lt;&lt; std::endl;
  input.close();
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix_a4614f32a3d6cf63e0d006f475e2d44c7_cgraph.png" border="0" usemap="#classcsc__matrix_a4614f32a3d6cf63e0d006f475e2d44c7_cgraph" alt=""/></div>
<map name="classcsc__matrix_a4614f32a3d6cf63e0d006f475e2d44c7_cgraph" id="classcsc__matrix_a4614f32a3d6cf63e0d006f475e2d44c7_cgraph">
<area shape="rect" id="node3" href="csc__matrix__load_8h.html#a41ea61857cb4937c99d1191af9db075b" title="readline" alt="" coords="177,5,250,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6a956b3480b07fe4abba088ed3c74de9"></a><!-- doxytag: member="csc_matrix::nnz" ref="a6a956b3480b07fe4abba088ed3c74de9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual idx_type <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns number of nonzeros in the matrix. </p>

<p>Implements <a class="el" href="classabstract__sparse__matrix.html#a17ed22a2da66ad522eaeba9d38774571">abstract_sparse_matrix&lt; idx_type, el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.size();
    }  
</pre></div>
</div>
</div>
<a class="anchor" id="a9cdbdb1db7e864d3626d63f65a820b70"></a><!-- doxytag: member="csc_matrix::resize" ref="a9cdbdb1db7e864d3626d63f65a820b70" args="(idx_type n_rows, idx_type n_cols, idx_type n_nzs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type, class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_type&#160;</td>
          <td class="paramname"><em>n_nzs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resizes the matrix. For use in preallocating space before factorization begins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>the number of rows in the resized matrix. </td></tr>
    <tr><td class="paramname">n_cols</td><td>the number of cols in the resized matrix. </td></tr>
    <tr><td class="paramname">n_nnzs</td><td>the number of non-zeros expected in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">        {
                <a class="code" href="classabstract__sparse__matrix.html#af0761a0f580d5da3655eaaf735020934">m_n_rows</a> = <a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>;
                <a class="code" href="classabstract__sparse__matrix.html#a7cb271a2aadd7e2bd0b287985789f4e1">m_n_cols</a> = <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>;
                <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>.resize(<a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a> + 1);
                <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>.resize(n_nzs);
                <a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>.resize(n_nzs);
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix_a9cdbdb1db7e864d3626d63f65a820b70_cgraph.png" border="0" usemap="#classcsc__matrix_a9cdbdb1db7e864d3626d63f65a820b70_cgraph" alt=""/></div>
<map name="classcsc__matrix_a9cdbdb1db7e864d3626d63f65a820b70_cgraph" id="classcsc__matrix_a9cdbdb1db7e864d3626d63f65a820b70_cgraph">
<area shape="rect" id="node3" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc" title="abstract_sparse_matrix::n_cols" alt="" coords="189,5,405,32"/><area shape="rect" id="node5" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c" title="abstract_sparse_matrix::n_rows" alt="" coords="187,56,408,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8eabd2e218a42e3a38d0b50493a669f3"></a><!-- doxytag: member="csc_matrix::save" ref="a8eabd2e218a42e3a38d0b50493a669f3" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type , class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be saved. All matrices saved are in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
  std::ofstream out(filename.c_str(), std::ios::out | std::ios::binary);
  <span class="keywordflow">if</span>(!out)
    <span class="keywordflow">return</span> <span class="keyword">false</span>;

  out.flags(std::ios_base::scientific);
  out.precision(10);
  std::string header; 
  <a class="code" href="csc__matrix__save_8h.html#aa7c9d04c7848fbb242800cad7f48c431">put_header</a>(header); 
  
  out &lt;&lt; header &lt;&lt; std::endl; 
  out &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#a144a350d9ac41f1325822724603b104c">n_rows</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#a80e493277e4813e3dff89f2eeee428bc">n_cols</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classcsc__matrix.html#a6a956b3480b07fe4abba088ed3c74de9">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
  
  <span class="keywordflow">for</span>(idx_type i = 0; i &lt; (idx_type) <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>.size()-1; i++)
    <span class="keywordflow">for</span>(idx_type j = <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[i]; j &lt; (idx_type) <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a>[i+1]; j++) {
                out &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a>[j]+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>[j] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
        
  out.close();
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcsc__matrix_a8eabd2e218a42e3a38d0b50493a669f3_cgraph.png" border="0" usemap="#classcsc__matrix_a8eabd2e218a42e3a38d0b50493a669f3_cgraph" alt=""/></div>
<map name="classcsc__matrix_a8eabd2e218a42e3a38d0b50493a669f3_cgraph" id="classcsc__matrix_a8eabd2e218a42e3a38d0b50493a669f3_cgraph">
<area shape="rect" id="node3" href="csc__matrix__save_8h.html#aa7c9d04c7848fbb242800cad7f48c431" title="put_header" alt="" coords="179,5,274,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f0b70b055118308c9ffd7acf596b17c"></a><!-- doxytag: member="csc_matrix::to_string" ref="a0f0b70b055118308c9ffd7acf596b17c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class idx_type , class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classcsc__matrix.html">csc_matrix</a>&lt; idx_type, el_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A string reprepsentation of this matrix. </dd></dl>

<p>Implements <a class="el" href="classabstract__sparse__matrix.html#a881263d3a128af1da87885f43e243b4c">abstract_sparse_matrix&lt; idx_type, el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream os;
  os &lt;&lt; <span class="stringliteral">&quot;Compressed Sparse Column Matrix (&quot;</span> &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#af0761a0f580d5da3655eaaf735020934">m_n_rows</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#a7cb271a2aadd7e2bd0b287985789f4e1">m_n_cols</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classcsc__matrix.html#a6a956b3480b07fe4abba088ed3c74de9">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
  
  os &lt;&lt; <span class="stringliteral">&quot;Column   Indices = &quot;</span>  &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#af3916fb4aa6133781a370cdbc95e5920">m_col_idx</a> &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">&quot;Row      Indices = &quot;</span>  &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#a5349db3095583ec31a1e9699576fa206">m_row_idx</a> &lt;&lt; std::endl;
  os &lt;&lt; <span class="stringliteral">&quot;Non-zero Values  = &quot;</span>  &lt;&lt; <a class="code" href="classabstract__sparse__matrix.html#ac5969b6288916a71d1c063ae72cb4ccf">m_x</a>       &lt;&lt; std::endl;
  <span class="keywordflow">return</span> os.str();
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="csc__matrix__declarations_8h_source.html">csc_matrix_declarations.h</a></li>
<li><a class="el" href="csc__matrix__ildl_8h_source.html">csc_matrix_ildl.h</a></li>
<li><a class="el" href="csc__matrix__load_8h_source.html">csc_matrix_load.h</a></li>
<li><a class="el" href="csc__matrix__save_8h_source.html">csc_matrix_save.h</a></li>
<li><a class="el" href="csc__matrix__to__string_8h_source.html">csc_matrix_to_string.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 27 2012 20:28:02 for matrix-factor by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
